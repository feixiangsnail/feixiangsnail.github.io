<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Access-Control-Allow-Origin" content="*">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>3D预览</title>
    <link rel="stylesheet" href="css/font-awesome.min.css">
    <style>
    html,
    body {
        font-family: Monospace;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
        width: 100%;
        height: 100%;
    }
    
    #box {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        margin: auto;
        width: 100%;
        height: 50%;
        padding-top: 20px;
        z-index: 999;
        text-align: center;
        color: purple;
        background:
    }
    
    img {
        width: 500px;
        height: 500px;
        margin-left: 100px;
    }
    
    p {
        text-align: center;
        font-size: 10px;
        font-weight: 700;
    }
    
    #loadText {
        font-size: 10px
    }
    
    #bar {
        position: absolute;
        left: 25%;
        width: 50%;
        height: 50px;
        top: 100px;
        color: yellow;
        display: flex;
        font-size: 10px;
        justify-content: space-between;
    }
    
    .menu {
        cursor: pointer;
    }
    
    .menu:hover {
        color: red;
    }
    
    #container {
        width: 100%;
        height: 100%;
        position: relative;
    }
    </style>
</head>

<body>
    <div id="box">
        <i class="fa fa-spinner  fa-spin fa-3x" aria-hidden="true"></i>
        <p id='loadText'>The model is onloading,please wait some seconds...</p>
    </div>
    <div id="container">
        <div id="bar">
            <div class="menu"><i class="fa fa-undo fa-3x" aria-hidden="true"></i></div>
            <div class="menu"><i class="fa fa-minus-circle fa-3x" aria-hidden="true"></i></div>
            <div class="menu"><i class="fa fa-repeat fa-3x" aria-hidden="true"></i></div>
        </div>
    </div>
</body>
<script src="js/three.js"></script>
<script src="js/pako.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/MAX.js"></script>
<script>
(function() {

    var camera, scene, renderer, speed = 0,
        stats;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var intersection = new THREE.Vector3();
    var offset = new THREE.Vector3();
    var plane = new THREE.Plane();
    var objects = [];
    var INTERSECTED, SELECTED;
    var box = document.getElementById('box');
    var container = document.getElementById('container')
    scene = new THREE.Scene();
    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);

    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('container').appendChild(renderer.domElement);
    camera = new THREE.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.lookAt(scene.position)
    camera.position.set(0, 5, 5)

    var urls = ['sky_LF.jpg', 'sky_RT.jpg',
        'sky_UP.jpg', 'sky_DN.jpg',
        'sky_FR.jpg', 'sky_BK.jpg'
    ]

    var cubeMap = new THREE.CubeTextureLoader().setPath('picture/sky/').load(urls);
    cubeMap.format = THREE.RGBFormat;

    var cubeShader = THREE.ShaderLib['cube']
    var cubeMaterial = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
    })
    cubeMaterial.uniforms['tCube'].value = cubeMap;
    var cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), cubeMaterial);
    scene.add(cubeMesh)





    scene.add(new THREE.AmbientLight(0x666666));
    var dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(-20, 30, 30)
    dirLight.castShadow = true;
    scene.add(dirLight)
    var mymax = new THREE.MAX();
    var key=false;
    mymax.load("model/462_BP_Fur_M_111_CDH001_00.mdll", function(group1) {
        group1.name = 'group1'
        group1.position.set(0, 0, 0)
        group1.rotation.set(0.5 * Math.PI, Math.PI, 1.1 * Math.PI)
        group1.castShadow = true;
        document.getElementById('box').style.display = 'none';
        document.getElementById('bar').style.display = 'flex';
        camera.lookAt(group1.position)
        scene.add(group1)
        key=true;
        for (var i = 0; i < group1.children.length; i++) {
            objects.push(group1.children[i])
        }
        
    })
    var controls = new THREE.OrbitControls(camera, renderer.domElement)
    controls.minDistance = 1;
    controls.maxDistance = 20;
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                SELECTED.parent.position.copy(intersection.sub(offset))
            }
            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            document.body.style.cursor = 'move'
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), INTERSECTED.parent.position)
            }
        } else {
            if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            document.body.style.cursor = ''
        }
    }

    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                offset.copy(intersection).sub(SELECTED.parent.position)
            }
        }
    }

    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            SELECTED = null;
        }
    }

    var menu = document.getElementsByClassName('menu');
    menu[0].onclick = function() {
        if (speed < 0) {
            speed = 0;
        }
        speed += 0.01
    }
    menu[1].onclick = function() {
        speed = 0
    }
    menu[2].onclick = function() {
        if (speed > 0) {
            speed = 0;
        }
        speed -= 0.01
    }

    function animate() {
        requestAnimationFrame(animate);
        if(key&&scene.getObjectByName('group1')){
            scene.getObjectByName('group1').rotation.z += speed;
        }
        


        controls.update();
        renderer.render(scene, camera);
    }
    animate();

})()
</script>

</html>
