<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Access-Control-Allow-Origin" content="*">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>3D预览</title>
    <link rel="stylesheet" href="css/font-awesome.min.css">
    <style>
    html,
    body {
        font-family: Monospace;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
    }
    
    #box {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        margin: auto;
        width: 100%;
        height: 50%;
        padding-top: 20px;
        z-index: 999;
        text-align: center;
        color: purple;
        background:
    }
    
    img {
        width: 500px;
        height: 500px;
        margin-left: 100px;
    }
    
    p {
        text-align: center;
        font-size: 10px;
        font-weight: 700;
    }
    
    #loadText {
        font-size: 10px
    }
    
    .bar {
        position: absolute;
        left: 25%;
        width: 50%;
        height: 50px;
        top: 100px;
        color: yellow;
        display: none;
        font-size: 10px;
        justify-content: space-between;
    }
    
    .bar2 {
        top: 80px;
        width: 30%;
        left: 35%;
    }
    
    .menu {
        cursor: pointer;
    }
    
    .menu:hover {
        color: red;
    }
    </style>
</head>
<body>
    <div id="box">
        <i class="fa fa-spinner  fa-spin fa-3x areloading" aria-hidden="true"></i>
        <p id='loadText'>The model is onloading,please wait some seconds...</p>
    </div>
    <div class="bar" id='bar1'>
        <div class="menu"><i class="fa fa-undo fa-3x" aria-hidden="true"></i></div>
        <div class="menu"><i class="fa fa-minus-circle fa-3x" aria-hidden="true"></i></div>
        <div class="menu"><i class="fa fa-repeat fa-3x" aria-hidden="true"></i></div>
    </div>
    <!-- <div class="bar bar2">
        <p>点击左转，多次点击加速</p>
        <p>停止</p>
        <p>点击右转，多次点击加速</p>
    </div> -->
    <div id="mybox"></div>
</body>

<script src="js/pts.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/MAX.js"></script>
<script>
(function() {
    function getQueryString(name) {
        var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
        var r = window.location.search.substr(1).match(reg);
        if (r != null) return unescape(r[2]);
        return null;
    }
    var url = getQueryString("url");
    var camera, scene, renderer, speed = 0,
        stats;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var intersection = new THREE.Vector3();
    var offset = new THREE.Vector3();
    var plane = new THREE.Plane();
    var objects = [];
    var INTERSECTED, SELECTED;
    var box = document.getElementById('box');
    scene = new THREE.Scene();
    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.lookAt(scene.position)
    camera.position.set(0, 5, 5)
    var r = 'picture/sky/'
    var urls = [r + 'sky_LF.jpg', r + 'sky_RT.jpg',
        r + 'sky_UP.jpg', r + 'sky_DN.jpg',
        r + 'sky_FR.jpg', r + 'sky_BK.jpg'
    ]
    var textureCube = new THREE.CubeTextureLoader().load(urls);
    textureCube.format = THREE.RGBFormat;
    textureCube.mapping = THREE.CubeReflectionMapping;
    scene.background = textureCube;
    scene.add(new THREE.AmbientLight(0x666666));
    var dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(-20, 30, 30)
    dirLight.castShadow = true;
    scene.add(dirLight)
    var mymax = new THREE.MAX();
    var key = false;
    mymax.load("model/462_BP_Fur_M_111_CDH001_00.mdll", function(group1) {
        group1.name = 'group1'
        group1.position.set(0, 0, 0)
        group1.rotation.set(0.5 * Math.PI, Math.PI, 1.1 * Math.PI)
        group1.castShadow = true;
        document.getElementById('box').style.display = 'none';
        document.getElementById('bar1').style.display = 'flex';
        camera.lookAt(group1.position)
        scene.add(group1)
        key = true;
        console.log(scene)
        for (var i = 0; i < group1.children.length; i++) {
            objects.push(group1.children[i])
        }
    })
    var controls = new THREE.OrbitControls(camera, renderer.domElement)
    controls.minDistance = 1;
    controls.maxDistance = 20;
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                SELECTED.parent.position.copy(intersection.sub(offset))
            }
            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            document.body.style.cursor = 'move'
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), INTERSECTED.parent.position)
            }
        } else {
            if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            document.body.style.cursor = ''
        }
    }
    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                offset.copy(intersection).sub(SELECTED.parent.position)
            }
        }
    }
    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            SELECTED = null;
        }
    }
    stats = initStats();
    document.body.appendChild(stats.domElement);
    var menu = document.getElementsByClassName('menu');
    menu[0].onclick = function() {
        if (speed < 0) {
            speed = 0;
        }
        speed += 0.01
    }
    menu[1].onclick = function() {
        speed = 0
    }
    menu[2].onclick = function() {
        if (speed > 0) {
            speed = 0;
        }
        speed -= 0.01
    }
    function initStats() {
        var stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        return stats;
    }
    function animate() {
        requestAnimationFrame(animate);
        if (key && scene.getObjectByName('group1')) {
            scene.getObjectByName('group1').rotation.z += speed;
        }
        stats.update();
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
})()
</script>

</html>
